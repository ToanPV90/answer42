# 9.6 Agent Responsibilities and AI Provider Assignments

## Overview

The Answer42 multi-agent system employs specialized agents, each optimized for specific types of academic paper analysis tasks. This document details the responsibilities of each agent type and provides the rationale for AI provider assignments based on empirical performance data and provider strengths.

## Agent Classification System

### Core Processing Agents

#### Paper Processor Agent

- **Primary Responsibility**: Text extraction and initial document parsing
- **AI Provider**: OpenAI GPT-4
- **Justification**: Superior OCR correction and text structure recognition
- **Key Capabilities**:
  - PDF text extraction with layout preservation
  - Table and figure identification
  - Section boundary detection
  - Reference list parsing
  - Mathematical notation handling

**Implementation**: See [9.6.2 Concrete Agent Implementations](9.6.2-concrete-agent-implementations.md) for full AIConfig-integrated implementation details.

#### Metadata Enhancement Agent

- **Primary Responsibility**: External metadata verification and enrichment
- **AI Provider**: OpenAI GPT-4 (with external API integration)
- **Justification**: Excellent at API integration and data synthesis
- **Key Capabilities**:
  - DOI resolution and validation
  - Crossref API integration for bibliographic data
  - Semantic Scholar API integration for citation metrics
  - Author disambiguation and affiliation resolution
  - Publication venue verification

```java
@Component
public class MetadataEnhancementAgent implements AIAgent {
    private final OpenAiChatModel chatModel;
    private final CrossrefApiClient crossrefClient;
    private final SemanticScholarApiClient semanticScholarClient;
    private final DOIResolver doiResolver;

    @Override
    public CompletableFuture<AgentResult> process(AgentTask task) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                Paper paper = task.getPaper();

                // Parallel metadata enhancement from multiple sources
                CompletableFuture<CrossrefMetadata> crossrefFuture = 
                    enhanceWithCrossref(paper);
                CompletableFuture<SemanticScholarMetadata> semanticFuture = 
                    enhanceWithSemanticScholar(paper);
                CompletableFuture<ResolvedDOI> doiFuture = 
                    resolveDOI(paper);

                // Wait for all enhancements to complete
                CompletableFuture.allOf(crossrefFuture, semanticFuture, doiFuture).join();

                // Synthesize results using AI
                EnhancedMetadata enhanced = synthesizeMetadata(
                    crossrefFuture.get(),
                    semanticFuture.get(),
                    doiFuture.get()
                );

                return AgentResult.success(enhanced, getProcessingMetrics());

            } catch (Exception e) {
                LoggingUtil.error(LOG, "process", "Metadata enhancement failed", e);
                return AgentResult.failure(e);
            }
        });
    }

    private EnhancedMetadata synthesizeMetadata(
            CrossrefMetadata crossref,
            SemanticScholarMetadata semantic,
            ResolvedDOI doi) {

        Prompt synthesisPrompt = Prompt.from("""
            Synthesize the following metadata from multiple sources into a coherent record:

            Crossref Data: {crossref}
            Semantic Scholar Data: {semantic}
            DOI Data: {doi}

            Resolve conflicts by prioritizing the most authoritative source.
            Return structured JSON with confidence scores for each field.
            """, Map.of(
                "crossref", crossref,
                "semantic", semantic,
                "doi", doi
            ));

        ChatResponse response = chatModel.call(synthesisPrompt);
        return parseMetadataResponse(response.getResult().getOutput().getContent());
    }
}
```

### Analysis Agents

#### Content Summarizer Agent

- **Primary Responsibility**: Multi-level summary generation
- **AI Provider**: Anthropic Claude
- **Justification**: Superior summarization capabilities and length control
- **Key Capabilities**:
  - Brief summaries (1-2 sentences)
  - Standard summaries (1-2 paragraphs)
  - Detailed summaries (multiple paragraphs with key findings)
  - Executive summaries for non-specialists
  - Technical summaries for domain experts

```java
@Component
public class ContentSummarizerAgent implements AIAgent {
    private final AnthropicChatModel claudeModel;
    private final SummaryLevelConfig summaryConfig;

    @Override
    public CompletableFuture<AgentResult> process(AgentTask task) {
        StructuredDocument document = task.getDocument();
        SummaryRequest request = task.getSummaryRequest();

        return CompletableFuture.supplyAsync(() -> {
            try {
                Map<SummaryLevel, String> summaries = new HashMap<>();

                for (SummaryLevel level : request.getRequestedLevels()) {
                    String summary = generateSummary(document, level);
                    summaries.put(level, summary);
                }

                return AgentResult.success(
                    new SummaryResult(summaries), 
                    getProcessingMetrics()
                );

            } catch (Exception e) {
                LoggingUtil.error(LOG, "process", "Summary generation failed", e);
                return AgentResult.failure(e);
            }
        });
    }

    private String generateSummary(StructuredDocument document, SummaryLevel level) {
        SummaryConfiguration config = summaryConfig.getConfig(level);

        Prompt summaryPrompt = Prompt.from("""
            Create a {level} summary of this academic paper:

            Title: {title}
            Abstract: {abstract}
            Content: {content}

            Requirements:
            - Length: {maxLength} words
            - Style: {style}
            - Audience: {audience}
            - Include: {includeElements}

            Focus on the main contributions, methodology, and key findings.
            """, Map.of(
                "level", level.getDisplayName(),
                "title", document.getTitle(),
                "abstract", document.getAbstract(),
                "content", document.getMainContent(),
                "maxLength", config.getMaxWords(),
                "style", config.getStyle(),
                "audience", config.getTargetAudience(),
                "includeElements", config.getRequiredElements()
            ));

        ChatResponse response = claudeModel.call(summaryPrompt);
        return response.getResult().getOutput().getContent();
    }
}
```

#### Concept Explainer Agent

- **Primary Responsibility**: Technical term explanation and concept clarification
- **AI Provider**: OpenAI GPT-4
- **Justification**: Exceptional ability to break down complex concepts into understandable explanations
- **Key Capabilities**:
  - Technical term glossary generation
  - Concept simplification for different education levels
  - Analogy creation for complex ideas
  - Prerequisite knowledge identification
  - Concept relationship mapping

```java
@Component
public class ConceptExplainerAgent implements AIAgent {
    private final OpenAiChatModel chatModel;
    private final ConceptDatabase conceptDb;
    private final EducationLevelMapper levelMapper;

    @Override
    public CompletableFuture<AgentResult> process(AgentTask task) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                StructuredDocument document = task.getDocument();
                ExplanationRequest request = task.getExplanationRequest();

                // Extract technical terms
                Set<String> technicalTerms = extractTechnicalTerms(document);

                // Generate explanations for each education level
                Map<EducationLevel, ConceptExplanations> explanations = new HashMap<>();

                for (EducationLevel level : request.getTargetLevels()) {
                    ConceptExplanations levelExplanations = generateExplanationsForLevel(
                        technicalTerms, 
                        document, 
                        level
                    );
                    explanations.put(level, levelExplanations);
                }

                return AgentResult.success(
                    new ConceptExplanationResult(explanations),
                    getProcessingMetrics()
                );

            } catch (Exception e) {
                LoggingUtil.error(LOG, "process", "Concept explanation failed", e);
                return AgentResult.failure(e);
            }
        });
    }

    private ConceptExplanations generateExplanationsForLevel(
            Set<String> terms, 
            StructuredDocument document, 
            EducationLevel level) {

        String contextualPrompt = buildContextualPrompt(terms, document, level);

        Prompt explanationPrompt = Prompt.from("""
            Explain the following technical concepts from this academic paper 
            for a {level} education level:

            Paper Context: {context}
            Terms to Explain: {terms}

            For each term, provide:
            1. Simple definition appropriate for {level} level
            2. Real-world analogy if helpful
            3. Why it's important in this research
            4. Related concepts the reader should know

            Use clear, engaging language without talking down to the reader.
            """, Map.of(
                "level", level.getDisplayName(),
                "context", document.getAbstractAndIntroduction(),
                "terms", String.join(", ", terms)
            ));

        ChatResponse response = chatModel.call(explanationPrompt);
        return parseExplanationResponse(response.getResult().getOutput().getContent());
    }
}
```

### Quality and Verification Agents

#### Quality Checker Agent

- **Primary Responsibility**: Accuracy verification and hallucination detection
- **AI Provider**: Anthropic Claude
- **Justification**: Superior fact-checking capabilities and reduced hallucination rates
- **Key Capabilities**:
  - Content accuracy verification against source material
  - Consistency checking across generated summaries
  - Citation accuracy validation
  - Logical coherence assessment
  - Bias detection and flagging

```java
@Component
public class QualityCheckerAgent implements AIAgent {
    private final AnthropicChatModel claudeModel;
    private final FactVerificationService verificationService;
    private final BiasDetectionService biasDetector;

    @Override
    public CompletableFuture<AgentResult> process(AgentTask task) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                QualityCheckRequest request = task.getQualityCheckRequest();

                // Perform multiple quality checks
                List<QualityCheckResult> results = new ArrayList<>();

                // Accuracy verification
                results.add(verifyAccuracy(request));

                // Consistency checking
                results.add(checkConsistency(request));

                // Bias detection
                results.add(detectBias(request));

                // Citation verification
                results.add(verifyCitations(request));

                // Generate overall quality assessment
                QualityAssessment assessment = generateQualityAssessment(results);

                return AgentResult.success(assessment, getProcessingMetrics());

            } catch (Exception e) {
                LoggingUtil.error(LOG, "process", "Quality check failed", e);
                return AgentResult.failure(e);
            }
        });
    }

    private QualityCheckResult verifyAccuracy(QualityCheckRequest request) {
        Prompt accuracyPrompt = Prompt.from("""
            Verify the accuracy of this generated content against the source material:

            Source Document: {source}
            Generated Content: {generated}

            Check for:
            1. Factual accuracy - are all claims supported by the source?
            2. Numerical accuracy - are statistics and figures correct?
            3. Contextual accuracy - is information presented in proper context?
            4. Completeness - are important details missing or oversimplified?

            Rate accuracy from 1-10 and provide specific feedback on any issues.
            """, Map.of(
                "source", request.getSourceDocument().getContent(),
                "generated", request.getGeneratedContent()
            ));

        ChatResponse response = claudeModel.call(accuracyPrompt);
        return parseAccuracyResponse(response.getResult().getOutput().getContent());
    }

    private QualityAssessment generateQualityAssessment(List<QualityCheckResult> results) {
        // Calculate overall quality score
        double overallScore = results.stream()
            .mapToDouble(QualityCheckResult::getScore)
            .average()
            .orElse(0.0);

        // Identify critical issues
        List<QualityIssue> criticalIssues = results.stream()
            .flatMap(result -> result.getIssues().stream())
            .filter(issue -> issue.getSeverity() == Severity.CRITICAL)
            .collect(Collectors.toList());

        // Generate recommendations
        List<String> recommendations = generateRecommendations(results);

        return new QualityAssessment(overallScore, criticalIssues, recommendations);
    }
}
```

#### Citation Formatter Agent

- **Primary Responsibility**: Citation extraction, formatting, and management
- **AI Provider**: OpenAI GPT-4
- **Justification**: Superior structured output generation and pattern recognition
- **Key Capabilities**:
  - Reference list parsing and structuring
  - Multiple citation style formatting (APA, MLA, Chicago, IEEE)
  - In-text citation identification
  - DOI and URL validation
  - Bibliography generation and organization

```java
@Component
public class CitationFormatterAgent implements AIAgent {
    private final OpenAiChatModel chatModel;
    private final CitationStyleRegistry styleRegistry;
    private final DOIValidator doiValidator;

    @Override
    public CompletableFuture<AgentResult> process(AgentTask task) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                CitationRequest request = task.getCitationRequest();
                StructuredDocument document = request.getDocument();

                // Extract citations from document
                List<RawCitation> rawCitations = extractCitations(document);

                // Parse and structure citations
                List<StructuredCitation> structuredCitations = 
                    rawCitations.stream()
                        .map(this::structureCitation)
                        .collect(Collectors.toList());

                // Validate and enhance citations
                List<ValidatedCitation> validatedCitations = 
                    validateCitations(structuredCitations);

                // Format citations in requested styles
                Map<CitationStyle, FormattedBibliography> bibliographies = 
                    formatBibliographies(validatedCitations, request.getRequestedStyles());

                return AgentResult.success(
                    new CitationResult(validatedCitations, bibliographies),
                    getProcessingMetrics()
                );

            } catch (Exception e) {
                LoggingUtil.error(LOG, "process", "Citation formatting failed", e);
                return AgentResult.failure(e);
            }
        });
    }

    private StructuredCitation structureCitation(RawCitation rawCitation) {
        Prompt structurePrompt = Prompt.from("""
            Parse this citation into structured components:

            Citation: {citation}

            Extract:
            - Authors (last name, first name, middle initial)
            - Title
            - Publication venue (journal, conference, book)
            - Publication date (year, month if available)
            - Volume, issue, page numbers
            - DOI or URL if present
            - Publication type (journal article, conference paper, book, etc.)

            Return as structured JSON with confidence scores for each field.
            """, Map.of("citation", rawCitation.getText()));

        ChatResponse response = chatModel.call(structurePrompt);
        return parseCitationStructure(response.getResult().getOutput().getContent());
    }

    private FormattedBibliography formatBibliography(
            List<ValidatedCitation> citations, 
            CitationStyle style) {

        CitationStyleFormatter formatter = styleRegistry.getFormatter(style);

        List<String> formattedEntries = citations.stream()
            .map(citation -> formatter.format(citation))
            .sorted() // Sort alphabetically by first author
            .collect(Collectors.toList());

        return new FormattedBibliography(style, formattedEntries);
    }
}
```

### Research and Discovery Agents

#### Perplexity Research Agent

- **Primary Responsibility**: External research and fact verification
- **AI Provider**: Perplexity API
- **Justification**: Specialized for real-time web search and research synthesis
- **Key Capabilities**:
  - Related paper discovery
  - Claim verification against current literature
  - Research trend identification
  - Expert opinion gathering
  - Current event contextualization

```java
@Component
public class PerplexityResearchAgent implements AIAgent {
    private final PerplexityChatModel perplexityModel;
    private final ResearchQueryBuilder queryBuilder;
    private final ResultSynthesizer synthesizer;

    @Override
    public CompletableFuture<AgentResult> process(AgentTask task) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                ResearchRequest request = task.getResearchRequest();

                // Build research queries based on paper content
                List<ResearchQuery> queries = queryBuilder.buildQueries(request);

                // Execute research queries in parallel
                List<CompletableFuture<ResearchResult>> futures = queries.stream()
                    .map(this::executeResearchQuery)
                    .collect(Collectors.toList());

                // Wait for all queries to complete
                CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

                // Collect and synthesize results
                List<ResearchResult> results = futures.stream()
                    .map(CompletableFuture::join)
                    .collect(Collectors.toList());

                SynthesizedResearch synthesis = synthesizer.synthesize(results, request);

                return AgentResult.success(synthesis, getProcessingMetrics());

            } catch (Exception e) {
                LoggingUtil.error(LOG, "process", "Research query failed", e);
                return AgentResult.failure(e);
            }
        });
    }

    private CompletableFuture<ResearchResult> executeResearchQuery(ResearchQuery query) {
        return CompletableFuture.supplyAsync(() -> {
            Prompt researchPrompt = Prompt.from("""
                Research the following query and provide comprehensive, cited information:

                Query: {query}
                Context: {context}

                Please provide:
                1. Current state of research on this topic
                2. Key recent findings and developments
                3. Expert opinions and consensus
                4. Relevant papers and studies
                5. Any controversies or debates

                Include proper citations and confidence levels for all claims.
                """, Map.of(
                    "query", query.getQueryText(),
                    "context", query.getContext()
                ));

            ChatResponse response = perplexityModel.call(researchPrompt);
            return parseResearchResponse(response.getResult().getOutput().getContent());
        });
    }
}
```

## Agent Provider Assignment Matrix

| Agent Type         | Primary Provider | Backup Provider  | Justification                                      |
| ------------------ | ---------------- | ---------------- | -------------------------------------------------- |
| Paper Processor    | OpenAI GPT-4     | Anthropic Claude | Superior structure recognition and OCR correction  |
| Metadata Enhancer  | OpenAI GPT-4     | Anthropic Claude | Excellent API integration and data synthesis       |
| Content Summarizer | Anthropic Claude | OpenAI GPT-4     | Best-in-class summarization with length control    |
| Concept Explainer  | OpenAI GPT-4     | Anthropic Claude | Exceptional ability to simplify complex concepts   |
| Quality Checker    | Anthropic Claude | OpenAI GPT-4     | Reduced hallucinations and superior fact-checking  |
| Citation Formatter | OpenAI GPT-4     | Anthropic Claude | Superior structured output and pattern recognition |
| Research Agent     | Perplexity       | OpenAI GPT-4     | Specialized real-time research capabilities        |

## Performance Metrics and Monitoring

### Agent Performance Tracking

```java
@Component
public class AgentPerformanceMonitor {
    private final Map<AgentType, AgentMetrics> agentMetrics = new ConcurrentHashMap<>();
    private final MeterRegistry meterRegistry;

    public void recordAgentExecution(AgentType agentType, Duration executionTime, boolean success) {
        AgentMetrics metrics = agentMetrics.computeIfAbsent(agentType, AgentMetrics::new);

        metrics.recordExecution(executionTime, success);

        // Update Micrometer metrics
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("agent.execution.time")
            .tag("agent.type", agentType.name())
            .tag("success", String.valueOf(success))
            .register(meterRegistry));

        Counter.builder("agent.execution.count")
            .tag("agent.type", agentType.name())
            .tag("success", String.valueOf(success))
            .register(meterRegistry)
            .increment();
    }

    public AgentHealthStatus getAgentHealth(AgentType agentType) {
        AgentMetrics metrics = agentMetrics.get(agentType);
        if (metrics == null) {
            return AgentHealthStatus.UNKNOWN;
        }

        double successRate = metrics.getSuccessRate();
        Duration avgExecutionTime = metrics.getAverageExecutionTime();

        if (successRate < 0.8 || avgExecutionTime.toSeconds() > 300) {
            return AgentHealthStatus.UNHEALTHY;
        } else if (successRate < 0.95 || avgExecutionTime.toSeconds() > 120) {
            return AgentHealthStatus.DEGRADED;
        } else {
            return AgentHealthStatus.HEALTHY;
        }
    }
}
```

This comprehensive agent responsibility framework ensures optimal task assignment and maintains high-quality outputs across all aspects of academic paper processing.
