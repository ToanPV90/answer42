# 9.7.2 Agent Memory Integration with Base Agents

## Overview

This document shows how the AgentTask and AgentMemoryStore database integration connects with the base agent implementations, providing persistent memory and task coordination for the multi-agent pipeline.

## Enhanced Base Agent with Memory Integration

### AbstractConfigurableAgent with Memory Support

```java
@Component
public abstract class AbstractConfigurableAgent {
    
    protected final AIConfig aiConfig;
    protected final ThreadConfig threadConfig;
    protected final AgentTaskService taskService;
    protected final AgentMemoryStoreRepository memoryRepository;
    protected final Logger LOG;
    
    protected AbstractConfigurableAgent(
            AIConfig aiConfig, 
            ThreadConfig threadConfig,
            AgentTaskService taskService,
            AgentMemoryStoreRepository memoryRepository) {
        this.aiConfig = aiConfig;
        this.threadConfig = threadConfig;
        this.taskService = taskService;
        this.memoryRepository = memoryRepository;
        this.LOG = LoggerFactory.getLogger(getClass());
    }
    
    /**
     * Process an agent task with memory integration and task tracking.
     */
    public final CompletableFuture<AgentResult> processTask(AgentTask task) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Mark task as started
                taskService.startTask(task.getId());
                
                // Check if we can skip processing based on memory
                if (shouldSkipProcessing(task)) {
                    JsonNode cachedResult = getCachedResult(task);
                    taskService.completeTask(task.getId(), cachedResult);
                    return AgentResult.fromCachedResult(task.getId(), cachedResult);
                }
                
                // Load agent-specific memory and user preferences
                loadAgentMemory(task.getUserId());
                
                // Execute the actual processing
                AgentResult result = processWithConfig(task);
                
                // Store result and update memory
                if (result.isSuccess()) {
                    taskService.completeTask(task.getId(), result.toJsonNode());
                    updateAgentMemory(task, result);
                } else {
                    taskService.failTask(task.getId(), result.getErrorMessage());
                }
                
                return result;
                
            } catch (Exception e) {
                LOG.error("Task processing failed for task {}: {}", task.getId(), e.getMessage(), e);
                taskService.failTask(task.getId(), e.getMessage());
                return AgentResult.failure(task.getId(), e.getMessage());
            }
        }, threadConfig.taskExecutor());
    }
    
    /**
     * Abstract method for agent-specific processing logic.
     */
    protected abstract AgentResult processWithConfig(AgentTask task);
    
    /**
     * Get the agent type for this agent.
     */
    public abstract String getAgentType();
    
    /**
     * Estimate processing time for load balancing.
     */
    public abstract Duration estimateProcessingTime(AgentTask task);
    
    /**
     * Check if processing can be skipped based on agent memory.
     */
    protected boolean shouldSkipProcessing(AgentTask task) {
        String cacheKey = buildCacheKey(task);
        return memoryRepository.findByKey(cacheKey).isPresent();
    }
    
    /**
     * Get cached result from agent memory.
     */
    protected JsonNode getCachedResult(AgentTask task) {
        String cacheKey = buildCacheKey(task);
        return memoryRepository.findByKey(cacheKey)
            .map(AgentMemoryStore::getData)
            .orElse(null);
    }
    
    /**
     * Load agent-specific memory and configuration.
     */
    protected void loadAgentMemory(UUID userId) {
        try {
            // Load user-specific agent configuration
            memoryRepository.findUserAgentConfig(userId, getAgentType())
                .ifPresent(this::applyUserConfiguration);
            
            // Load general agent memory
            loadGeneralAgentMemory();
            
        } catch (Exception e) {
            LOG.warn("Failed to load agent memory for user {}: {}", userId, e.getMessage());
        }
    }
    
    /**
     * Update agent memory after successful processing.
     */
    protected void updateAgentMemory(AgentTask task, AgentResult result) {
        try {
            // Cache result if appropriate
            if (shouldCacheResult(task, result)) {
                String cacheKey = buildCacheKey(task);
                AgentMemoryStore cache = AgentMemoryStore.builder()
                    .key(cacheKey)
                    .data(result.toJsonNode())
                    .createdAt(Instant.now())
                    .updatedAt(Instant.now())
                    .build();
                memoryRepository.save(cache);
            }
            
            // Update agent-specific memory
            updateAgentSpecificMemory(task, result);
            
        } catch (Exception e) {
            LOG.warn("Failed to update agent memory for task {}: {}", task.getId(), e.getMessage());
        }
    }
    
    /**
     * Build cache key for task result caching.
     */
    protected String buildCacheKey(AgentTask task) {
        String inputHash = DigestUtils.md5Hex(task.getInput().toString());
        return String.format("agent_%s_cache_%s", getAgentType(), inputHash);
    }
    
    /**
     * Determine if result should be cached.
     */
    protected boolean shouldCacheResult(AgentTask task, AgentResult result) {
        // Default: cache successful results for expensive operations
        return result.isSuccess() && estimateProcessingTime(task).toSeconds() > 30;
    }
    
    /**
     * Apply user-specific configuration from memory.
     */
    protected void applyUserConfiguration(AgentMemoryStore config) {
        // Override in subclasses to apply specific configurations
        LOG.debug("Applying user configuration for agent {}", getAgentType());
    }
    
    /**
     * Load general agent memory (processed papers, etc.).
     */
    protected void loadGeneralAgentMemory() {
        // Override in subclasses if needed
    }
    
    /**
     * Update agent-specific memory after processing.
     */
    protected void updateAgentSpecificMemory(AgentTask task, AgentResult result) {
        // Override in subclasses to update specific memory
    }
    
    /**
     * Get current load status for monitoring.
     */
    protected ThreadPoolLoadStatus getLoadStatus() {
        ThreadPoolExecutor executor = (ThreadPoolExecutor) threadConfig.taskExecutor();
        return new ThreadPoolLoadStatus(
            executor.getActiveCount(),
            executor.getPoolSize(),
            executor.getMaximumPoolSize(),
            executor.getQueue().size()
        );
    }
    
    /**
     * Create processing metrics with memory usage information.
     */
    protected ProcessingMetrics createProcessingMetrics() {
        return ProcessingMetrics.builder()
            .agentType(getAgentType())
            .processingTime(System.currentTimeMillis())
            .threadPoolStatus(getLoadStatus())
            .memoryUsage(getMemoryUsage())
            .build();
    }
    
    /**
     * Get memory usage statistics for this agent.
     */
    protected AgentMemoryUsage getMemoryUsage() {
        List<AgentMemoryStore> agentMemories = memoryRepository.findAgentCaches(getAgentType());
        long totalMemorySize = agentMemories.stream()
            .mapToLong(memory -> memory.getData().toString().length())
            .sum();
        
        return new AgentMemoryUsage(
            agentMemories.size(),
            totalMemorySize,
            calculateMemoryEfficiency()
        );
    }
    
    /**
     * Calculate memory efficiency (cache hit rate).
     */
    protected double calculateMemoryEfficiency() {
        // This would be tracked over time - simplified implementation
        return 0.75; // 75% cache hit rate as example
    }
}
```

## Enhanced Agent Implementations

### Paper Processor Agent with Memory Integration

```java
@Component
public class PaperProcessorAgent extends OpenAIBasedAgent {
    
    public PaperProcessorAgent(
            AIConfig aiConfig,
            ThreadConfig threadConfig,
            AgentTaskService taskService,
            AgentMemoryStoreRepository memoryRepository) {
        super(aiConfig, threadConfig, taskService, memoryRepository);
    }
    
    @Override
    public String getAgentType() {
        return "paper-processor";
    }
    
    @Override
    protected AgentResult processWithConfig(AgentTask task) {
        String paperId = task.getInput().get("paperId").asText();
        
        // Check if paper was already processed using memory
        if (isPaperAlreadyProcessed(paperId)) {
            LOG.info("Paper {} already processed, skipping", paperId);
            return AgentResult.skipped(task.getId(), "Paper already processed");
        }
        
        try {
            // Process the paper using OpenAI
            ProcessingResult result = processPaper(paperId, task.getUserId());
            
            return AgentResult.success(task.getId(), result);
            
        } catch (Exception e) {
            LOG.error("Failed to process paper {}: {}", paperId, e.getMessage(), e);
            return AgentResult.failure(task.getId(), e.getMessage());
        }
    }
    
    @Override
    protected boolean shouldSkipProcessing(AgentTask task) {
        String paperId = task.getInput().get("paperId").asText();
        return isPaperAlreadyProcessed(paperId);
    }
    
    @Override
    protected void updateAgentSpecificMemory(AgentTask task, AgentResult result) {
        if (result.isSuccess()) {
            String paperId = task.getInput().get("paperId").asText();
            updateProcessedPapersMemory(paperId);
        }
    }
    
    /**
     * Check if paper has been processed using agent memory.
     */
    private boolean isPaperAlreadyProcessed(String paperId) {
        return memoryRepository.findProcessedPapersMemory()
            .map(memory -> memory.hasPaperBeenProcessed(paperId))
            .orElse(false);
    }
    
    /**
     * Update processed papers memory.
     */
    private void updateProcessedPapersMemory(String paperId) {
        AgentMemoryStore memory = memoryRepository.findProcessedPapersMemory()
            .orElse(AgentMemoryStore.createProcessedPapersMemory(new ArrayList<>()));
        
        memory.addProcessedPaperId(paperId);
        memoryRepository.save(memory);
        
        LOG.info("Updated processed papers memory with paper {}", paperId);
    }
    
    private ProcessingResult processPaper(String paperId, UUID userId) {
        // Actual paper processing logic using OpenAI client
        ChatClient chatClient = aiConfig.openAiChatClient(userId);
        
        // Implementation details...
        return new ProcessingResult(paperId, "processed content", Map.of());
    }
    
    @Override
    public Duration estimateProcessingTime(AgentTask task) {
        // Estimate based on paper size and complexity
        return Duration.ofMinutes(5); // Base estimate: 5 minutes per paper
    }
}
```

### Content Summarizer Agent with Memory Integration

```java
@Component
public class ContentSummarizerAgent extends AnthropicBasedAgent {
    
    private final PaperRepository paperRepository;
    
    public ContentSummarizerAgent(
            AIConfig aiConfig,
            ThreadConfig threadConfig,
            AgentTaskService taskService,
            AgentMemoryStoreRepository memoryRepository,
            PaperRepository paperRepository) {
        super(aiConfig, threadConfig, taskService, memoryRepository);
        this.paperRepository = paperRepository;
    }
    
    @Override
    public String getAgentType() {
        return "content-summarizer";
    }
    
    @Override
    protected AgentResult processWithConfig(AgentTask task) {
        String paperId = task.getInput().get("paperId").asText();
        String summaryType = task.getInput().get("summaryType").asText();
        
        try {
            // Load paper from database
            Paper paper = paperRepository.findById(UUID.fromString(paperId))
                .orElseThrow(() -> new EntityNotFoundException("Paper not found: " + paperId));
            
            // Generate summary using Anthropic
            SummaryResult summary = generateSummary(paper, summaryType, task.getUserId());
            
            // Store summary in paper entity
            updatePaperWithSummary(paper, summary, summaryType);
            
            return AgentResult.success(task.getId(), summary);
            
        } catch (Exception e) {
            LOG.error("Failed to generate summary for paper {}: {}", paperId, e.getMessage(), e);
            return AgentResult.failure(task.getId(), e.getMessage());
        }
    }
    
    @Override
    protected void applyUserConfiguration(AgentMemoryStore config) {
        // Apply user preferences for summary generation
        String preferredLength = config.getConfigValue("preferredSummaryLength", String.class);
        String academicField = config.getConfigValue("academicField", String.class);
        Boolean includeMethodology = config.getConfigValue("includeMethodology", Boolean.class);
        
        LOG.debug("Applied user config: length={}, field={}, methodology={}", 
                  preferredLength, academicField, includeMethodology);
    }
    
    @Override
    protected boolean shouldCacheResult(AgentTask task, AgentResult result) {
        // Cache summaries for expensive summary types
        String summaryType = task.getInput().get("summaryType").asText();
        return result.isSuccess() && ("detailed".equals(summaryType) || "comprehensive".equals(summaryType));
    }
    
    private SummaryResult generateSummary(Paper paper, String summaryType, UUID userId) {
        ChatClient chatClient = aiConfig.anthropicChatClient(userId);
        
        Prompt summaryPrompt = buildSummaryPrompt(paper, summaryType);
        ChatResponse response = chatClient.prompt(summaryPrompt).call().chatResponse();
        
        return new SummaryResult(
            summaryType,
            response.getResult().getOutput().getContent(),
            extractKeyPoints(response),
            Instant.now()
        );
    }
    
    private void updatePaperWithSummary(Paper paper, SummaryResult summary, String summaryType) {
        switch (summaryType) {
            case "brief":
                paper.setSummaryBrief(summary.getContent());
                break;
            case "standard":
                paper.setSummaryStandard(summary.getContent());
                break;
            case "detailed":
                paper.setSummaryDetailed(summary.getContent());
                break;
        }
        paper.setUpdatedAt(LocalDateTime.now());
        paperRepository.save(paper);
    }
    
    @Override
    public Duration estimateProcessingTime(AgentTask task) {
        String summaryType = task.getInput().get("summaryType").asText();
        return switch (summaryType) {
            case "brief" -> Duration.ofMinutes(2);
            case "standard" -> Duration.ofMinutes(5);
            case "detailed" -> Duration.ofMinutes(10);
            default -> Duration.ofMinutes(5);
        };
    }
}
```

## Memory Management Service

### AgentMemoryService

```java
@Service
@Transactional
public class AgentMemoryService {
    
    private final AgentMemoryStoreRepository memoryRepository;
    private final UserPreferencesRepository preferencesRepository;
    private final Logger logger = LoggerFactory.getLogger(AgentMemoryService.class);
    
    public AgentMemoryService(
            AgentMemoryStoreRepository memoryRepository,
            UserPreferencesRepository preferencesRepository) {
        this.memoryRepository = memoryRepository;
        this.preferencesRepository = preferencesRepository;
    }
    
    /**
     * Initialize agent memory for a user with their preferences.
     */
    public void initializeUserAgentMemory(UUID userId) {
        UserPreferences preferences = preferencesRepository.findByUserId(userId)
            .orElse(new UserPreferences(userId));
        
        // Create memory entries for each agent type based on user preferences
        Map<String, String> agentTypes = Map.of(
            "content-summarizer", "Content Summarizer",
            "concept-explainer", "Concept Explainer",
            "citation-formatter", "Citation Formatter",
            "quality-checker", "Quality Checker"
        );
        
        agentTypes.forEach((agentType, agentName) -> {
            String memoryKey = AgentMemoryStore.buildUserAgentConfigKey(userId, agentType);
            
            if (memoryRepository.findByKey(memoryKey).isEmpty()) {
                Map<String, Object> config = buildDefaultAgentConfig(agentType, preferences);
                AgentMemoryStore memory = AgentMemoryStore.createUserAgentConfig(userId, agentType, config);
                memoryRepository.save(memory);
                
                logger.info("Initialized agent memory for user {} and agent {}", userId, agentName);
            }
        });
    }
    
    /**
     * Update user agent configuration in memory.
     */
    public void updateUserAgentConfig(UUID userId, String agentType, Map<String, Object> config) {
        String memoryKey = AgentMemoryStore.buildUserAgentConfigKey(userId, agentType);
        
        AgentMemoryStore memory = memoryRepository.findByKey(memoryKey)
            .orElse(AgentMemoryStore.createUserAgentConfig(userId, agentType, config));
        
        // Update the configuration
        ObjectNode dataNode = (ObjectNode) memory.getData();
        config.forEach((key, value) -> {
            if (value instanceof String) {
                dataNode.put(key, (String) value);
            } else if (value instanceof Integer) {
                dataNode.put(key, (Integer) value);
            } else if (value instanceof Boolean) {
                dataNode.put(key, (Boolean) value);
            } else if (value instanceof Double) {
                dataNode.put(key, (Double) value);
            }
        });
        
        memory.setUpdatedAt(Instant.now());
        memoryRepository.save(memory);
        
        logger.info("Updated agent config for user {} and agent {}", userId, agentType);
    }
    
    /**
     * Get agent memory statistics for monitoring.
     */
    public AgentMemoryStatistics getMemoryStatistics() {
        Object[] stats = memoryRepository.getMemoryUsageStats();
        List<Object[]> usageByPrefix = memoryRepository.getMemoryUsageByPrefix();
        
        return AgentMemoryStatistics.builder()
            .totalEntries(((Number) stats[0]).longValue())
            .totalSizeBytes(((Number) stats[1]).longValue())
            .usageByPrefix(usageByPrefix.stream()
                .collect(Collectors.toMap(
                    row -> (String) row[0],
                    row -> ((Number) row[1]).longValue()
                )))
            .lastUpdated(Instant.now())
            .build();
    }
    
    /**
     * Clean up stale memory entries.
     */
    @Scheduled(fixedRate = 3600000) // Run every hour
    public void cleanupStaleMemory() {
        // Keep agent memory for 30 days
        Instant cutoff = Instant.now().minus(30, ChronoUnit.DAYS);
        int deletedCount = memoryRepository.deleteStaleEntries(cutoff);
        
        if (deletedCount > 0) {
            logger.info("Cleaned up {} stale memory entries", deletedCount);
        }
    }
    
    private Map<String, Object> buildDefaultAgentConfig(String agentType, UserPreferences preferences) {
        Map<String, Object> config = new HashMap<>();
        
        // Common configuration
        config.put("academicField", preferences.getAcademicField());
        config.put("createdAt", Instant.now().toString());
        
        // Agent-specific configuration
        switch (agentType) {
            case "content-summarizer":
                config.put("preferredSummaryLength", "standard");
                config.put("includeMethodology", true);
                config.put("includeConclusions", true);
                break;
                
            case "concept-explainer":
                config.put("explanationLevel", "intermediate");
                config.put("includeExamples", true);
                config.put("includeReferences", true);
                break;
                
            case "citation-formatter":
                config.put("defaultCitationStyle", "APA");
                config.put("includeDOIs", true);
                config.put("validateCitations", true);
                break;
                
            case "quality-checker":
                config.put("strictness", "medium");
                config.put("checkBias", true);
                config.put("checkConsistency", true);
                break;
        }
        
        return config;
    }
}
```

This integration provides a complete memory-aware agent system that leverages the database for persistence, task coordination, and user-specific configuration management.
